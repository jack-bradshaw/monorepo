/*
 * Copyright 2023 The Bazel Authors. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.devtools.build.android.sandboxedsdktoolbox.mixin;

import static com.google.common.base.Preconditions.checkArgument;

import com.google.common.collect.ImmutableMap;
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.EnumMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import picocli.CommandLine.Option;

/** Command line mixin for parsing an AAPT xml tree dump of the host app. */
public final class HostAppInfoMixin {
  private enum HostAppInfoType {
    PACKAGE_NAME,
    VERSION_CODE,
    MIN_SDK_VERSION,
  }

  private static final ImmutableMap<HostAppInfoType, Pattern> PATTERNS =
      ImmutableMap.of(
          HostAppInfoType.PACKAGE_NAME,
          Pattern.compile("A: package=\"(.*?)\""),
          HostAppInfoType.VERSION_CODE,
          Pattern.compile(
              "http:\\/\\/schemas.android.com\\/apk\\/res\\/android:versionCode\\(.*\\)=(\\d*)"),
          HostAppInfoType.MIN_SDK_VERSION,
          Pattern.compile(
              "http:\\/\\/schemas.android.com\\/apk\\/res\\/android:minSdkVersion\\(.*\\)=(\\d*)"));

  private final Map<HostAppInfoType, String> parsedInfoMap = new EnumMap<>(HostAppInfoType.class);

  @Option(
      names = "--manifest-xml-tree",
      description = "Path to the manifest xml tree file, as generated by AAPT2 dump command.",
      required = true)
  public void setManifestXmlTreePath(Path manifestXmlTreePath) {
    try (BufferedReader reader = Files.newBufferedReader(manifestXmlTreePath)) {
      reader.lines().forEach(this::parseXmlTreeLine);
    } catch (IOException e) {
      throw new IllegalArgumentException("Invalid manifest xml tree file.", e);
    }
  }

  private void parseXmlTreeLine(String line) {
    for (HostAppInfoType type : HostAppInfoType.values()) {
      if (parsedInfoMap.containsKey(type)) {
        continue;
      }
      Matcher matcher = PATTERNS.get(type).matcher(line);
      if (matcher.find()) {
        parsedInfoMap.put(type, matcher.group(1));
      }
    }
  }

  public String getPackageName() {
    checkArgument(
        parsedInfoMap.containsKey(HostAppInfoType.PACKAGE_NAME),
        "Package name missing from manifest xml tree file.");
    return parsedInfoMap.get(HostAppInfoType.PACKAGE_NAME);
  }

  public int getVersionCode() {
    checkArgument(
        parsedInfoMap.containsKey(HostAppInfoType.VERSION_CODE),
        "Version code missing from manifest xml tree file.");
    return Integer.parseInt(parsedInfoMap.get(HostAppInfoType.VERSION_CODE));
  }

  public int getMinSdkVersion() {
    checkArgument(
        parsedInfoMap.containsKey(HostAppInfoType.MIN_SDK_VERSION),
        "Min SDK version missing from manifest xml tree file.");
    return Integer.parseInt(parsedInfoMap.get(HostAppInfoType.MIN_SDK_VERSION));
  }

  private HostAppInfoMixin() {}
}
