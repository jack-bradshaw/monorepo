package com.jackbradshaw.site.tests

import com.google.devtools.build.runfiles.Runfiles
import com.microsoft.playwright.Browser
import com.microsoft.playwright.BrowserType
import com.microsoft.playwright.Locator
import com.microsoft.playwright.Page
import com.microsoft.playwright.Playwright
import io.ktor.http.ContentType
import io.ktor.http.HttpStatusCode
import io.ktor.server.application.call
import io.ktor.server.engine.ApplicationEngine
import io.ktor.server.engine.embeddedServer
import io.ktor.server.netty.Netty
import io.ktor.server.request.ApplicationRequest
import io.ktor.server.request.uri
import io.ktor.server.response.respondBytes
import io.ktor.server.response.respondText
import io.ktor.server.routing.get
import io.ktor.server.routing.routing
import java.io.File
import java.net.URI
import java.nio.file.Path
import java.nio.file.Paths
import java.util.concurrent.TimeUnit
import kotlinx.coroutines.runBlocking

/**
 * Runs the site in a local server and provides instrumentation for accessing it.
 *
 * The [setup] function must be called before using the harness, and the [tearDown] function must be
 * called when the harness is no longer needed.
 */
class TestHarness {

  /** Provides access to files generated by build dependencies. */
  private lateinit var runfiles: Runfiles

  /** The root directory of the site in [runfiles]. */
  private lateinit var site: File

  /** A local server that serves the site from [site]. */
  private lateinit var server: ApplicationEngine

  /**
   * The port the server is running on, assigned a meaningful value once the [server] has been
   * started.
   */
  private var port: Int = -1

  /** Instrumentation to access/control the site for testing. */
  private lateinit var playwright: Playwright

  /** The browser that renders the site for testing. */
  private lateinit var browser: Browser

  /** The context associated with [browser]. */
  private lateinit var browserContext: com.microsoft.playwright.BrowserContext

  /** Starts the server and sets the browser screen width to [screenWidth]. */
  fun setup(screenWidth: ScreenWidth = ScreenWidth.MEDIUM) {
    setupRunfiles()
    setupInstrumentation(screenWidth)
    setupServer()
  }

  /** Initializes [runfiles] and loads [site]. */
  private fun setupRunfiles() {
    runfiles = Runfiles.preload().unmapped()

    site =
        File(runfiles.rlocation("_main/first_party/site/site")).also {
          check(it.exists()) { "Site not found. Expected at $it in runfiles." }
        }
  }

  /** Initializes [playwright], [browser], and [browserContext]. */
  private fun setupInstrumentation(width: ScreenWidth) {
    playwright = Playwright.create()

    // Reduce test flakiness by disabling GPU acceleration and other non-deterministic features.
    val launchOptions =
        BrowserType.LaunchOptions()
            .setHeadless(true)
            .setArgs(
                listOf(
                    "--disable-gpu",
                    "--disable-font-subpixel-positioning",
                    "--disable-lcd-text",
                    "--disable-threaded-animation",
                    "--disable-threaded-scrolling",
                    "--disable-in-process-stack-traces",
                    "--disable-checker-imaging",
                    "--force-color-profile=srgb"))
    browser = playwright.chromium().launch(launchOptions)

    browserContext =
        browser.newContext(
            Browser.NewContextOptions().setViewportSize(width.asPixels, VIEW_PORT_HEIGHT_PX))
    browserContext.setDefaultNavigationTimeout(TimeUnit.SECONDS.toMillis(60).toDouble())
    browserContext.setDefaultTimeout(TimeUnit.SECONDS.toMillis(60).toDouble())
  }

  /** Initializes [server] and assigns its port to [port]. */
  private fun setupServer() {
    server =
        embeddedServer(Netty, port = RANDOM_PORT_SELECTOR, host = HOSTNAME) {
          routing {
            get("/{...}") {
              val responseFile = call.request.toSiteFile()
              if (responseFile.exists() && responseFile.isFile) {
                val contentType =
                    when {
                      responseFile.name.endsWith(".html") -> ContentType.Text.Html
                      responseFile.name.endsWith(".css") -> ContentType.Text.CSS
                      responseFile.name.endsWith(".js") -> ContentType.Application.JavaScript
                      responseFile.name.endsWith(".png") -> ContentType.Image.PNG
                      responseFile.name.endsWith(".jpg") -> ContentType.Image.JPEG
                      else -> ContentType.Application.OctetStream
                    }
                call.respondBytes(responseFile.readBytes(), contentType)
              } else {
                call.respondText("Not Found", status = HttpStatusCode.NotFound)
              }
            }
          }
        }

    server.start(wait = false)

    runBlocking { port = server.resolvedConnectors().first().port }
  }

  /**
   * Releases the resources used by this harness. This function is safe to call even if [setup] was
   * never called.
   */
  fun tearDown() {
    if (::browserContext.isInitialized) browserContext.close()
    if (::browser.isInitialized) browser.close()
    if (::playwright.isInitialized) playwright.close()
    if (::server.isInitialized) server.stop(0, 0)
  }

  /** Opens a new browser page at [page] (relative to the site root). */
  fun openPage(page: URI): Page =
      browserContext.newPage().apply {
        navigate(endpoint().resolve(page).toString())
        waitForFunction(
            "document.fonts.status === 'loaded' && Array.from(document.images).every(img => img.complete)")
      }

  /** Returns the runfile at [path] (relative to the runfiles root). */
  fun getRunfile(path: Path): Path = Paths.get(runfiles.rlocation(path.toString()))

  /** Returns the endpoint of the server, as a URI containing protocol, host, and port. */
  fun endpoint(): URI = URI("http", null, HOSTNAME, port, null, null, null)

  /**
   * Finds the first element in [page] that matches [locator], scrolls it into view (if necessary),
   * and returns it.
   */
  fun findElement(page: Page, locator: String): Locator =
      page.locator(locator).first().also { it.scrollIntoViewIfNeeded() }

  /** Resolves the file in [site] that satisfies this request. */
  private fun ApplicationRequest.toSiteFile(): File {
    val path = if (uri == "/" || uri.isEmpty()) "index.html" else uri.removePrefix("/")
    val location = File(site, path)

    return if (location.isDirectory) File(location, "index.html") else location
  }

  companion object {
    /** The hostname for the server. */
    private const val HOSTNAME = "localhost"

    /** The value which requests a random port when passed to [embeddedServer]. */
    private const val RANDOM_PORT_SELECTOR = 0

    /** The height of the browser viewport, measured in pixels. */
    private const val VIEW_PORT_HEIGHT_PX = 1080
  }
}

/** The horizontal width of a browser viewport. */
enum class ScreenWidth(val asPixels: Int) {
  /** A small screen (e.g. phone). */
  SMALL(480),

  /** A medium screen (e.g. tablet). */
  MEDIUM(1024),

  /** A large screen (e.g. desktop). */
  LARGE(1920)
}
